{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"DriveWire Documentation","text":"<ul> <li>DriveWire Documentation<ul> <li>Before you start</li> <li>Get started with DriveWire<ul> <li>Step 1: Choose a DriveWire implementation</li> <li>Step 2: Install DriveWire</li> <li>Step 3: Run DriveWire</li> <li>Step 4: Configure DriveWire</li> </ul> </li> <li>Carry on</li> <li>Technical Information</li> <li>Bugs</li> <li>Source Code</li> <li>License</li> </ul> </li> </ul> <p>Generalization (Review Needed)</p> <p>The following home page has been updated to reflect the multi-implementation nature of the DriveWire project.</p>"},{"location":"#before-you-start","title":"Before you start","text":"<p>DriveWire is a flexible server and protocol suite for the TRS-80 Color Computer and compatible systems. It provides virtual disks, networking, and other services.</p> <p>Please consult the DriveWire 3 documentation for the legacy information needed to get your CoCo ready to talk to DriveWire.</p>"},{"location":"#get-started-with-drivewire","title":"Get started with DriveWire","text":""},{"location":"#step-1-choose-a-drivewire-implementation","title":"Step 1: Choose a DriveWire implementation","text":"<p>This project contains multiple implementations of the DriveWire server: - Java Server &amp; GUI: The classic cross-platform implementation. - MicroPython Server: A lightweight version for microcontrollers like the Raspberry Pi Pico.</p> <p>Download the current version from the project repository.</p>"},{"location":"#step-2-install-drivewire","title":"Step 2: Install DriveWire","text":"<p>See Installation for detailed instructions.</p>"},{"location":"#step-3-run-drivewire","title":"Step 3: Run DriveWire","text":"<p>To start the Java-based server and GUI, see The DriveWire GUI. For other implementations, see their respective documentation.</p>"},{"location":"#step-4-configure-drivewire","title":"Step 4: Configure DriveWire","text":"<p>To configure DriveWire, see Configuration.</p>"},{"location":"#carry-on","title":"Carry on","text":"<p>Here are some additional topics that all users may find interesting or helpful.</p> <ul> <li>Using DriveWire</li> <li>Getting Help</li> <li>Solving Low Memory Issues</li> </ul>"},{"location":"#technical-information","title":"Technical Information","text":"<p>These topics are probably only of interest to programmers, hackers, and advanced users.</p> <ul> <li>Config.xml (wip, and not applicable to current release)</li> <li>OS-9 Modules</li> <li>The 'dw' Commands</li> <li>Building from Source</li> <li>Writing Network Capable Software</li> <li>DriveWire Specification</li> <li>Becker Port Specification</li> </ul>"},{"location":"#bugs","title":"Bugs","text":"<p>Feel free to post bug reports in the tickets tracker (Tickets tab above). However this is largely unmaintained at this point.</p>"},{"location":"#source-code","title":"Source Code","text":"<p>The code is hosted in git (see the Git tab above). To get a copy of the repository: <code>git clone git://git.code.sf.net/p/drivewireserver/git drivewireserver</code></p>"},{"location":"#license","title":"License","text":"<p>DriveWire is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.</p> <p>DriveWire is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.</p>"},{"location":"Add_DriveWire_Drivers/","title":"Add the DriveWire Drivers to Your Existing System","text":"<ul> <li>Option 1: Boot from a DriveWire .dsk but use your device as <code>/dd</code></li> <li>Option 2: Boot from your device</li> </ul>"},{"location":"Becker_port_specification/","title":"Becker Port Spec","text":"<p>The \"Becker\" port is a simple interface used in CoCo emulators and Gary Becker's CoCo3FPGA project to allow high speed I/O between the CoCo and the DriveWire server. It assumes there is some logic external to the CoCo that handles the physical I/O and can buffer as needed. </p> <p>The interface uses 2 addresses, one for status and one for the actual I/O. </p> <p>The read status port is &amp;HFF41 </p> <p>The only bit used out of bit 0 to bit 7 is bit #1 </p> <p>If there is data to read then bit #1 will be set to 1 </p> <p>The read/write port is &amp;HFF42 </p> <p>When reading you must make sure you only read when data is present by the status bit. </p> <p>As far as writing you just write the data to the port. </p>"},{"location":"Beta/","title":"Beta Info","text":"<p>Beta information can be found here</p>"},{"location":"Building_from_source/","title":"Building from Source","text":"<p>[!WARNING] These instructions may be outdated.</p> <p>You need to have the correct RXTX library file for your platform. You also must have the <code>.properties</code> configuration files in the same folder as your single <code>DriveWire.jar</code> file.</p> <p>You should be able to launch the DriveWire server with the normal <code>java \u2013jar DriveWire.jar</code> command on any platform.</p> <p>The jar file is platform independent, so once it is built you can copy it to Windows, Linux, macOS, etc. without rebuilding.</p>"},{"location":"Building_from_source/#requirements","title":"Requirements","text":"<ul> <li>Java version 1.5 or later</li> <li>Apache Ant configured for your platform</li> </ul>"},{"location":"Client_CoCo/","title":"Client (CoCo) Side Software (ROMs, Cassette Images, etc.)","text":""},{"location":"Client_CoCo/#official-resources","title":"Official Resources","text":"<p>For the most accurate and detailed information on legacy DriveWire hardware and software, please visit the official Cloud 9 site:</p> <ul> <li>Cloud 9 DriveWire Page: http://cloud9tech.com/Cloud-9/Hardware/DriveWire3.html</li> <li>DriveWire 3 User Manual (PDF): http://cloud9tech.com/Cloud-9/Support/DriveWire%203%20User%20Manual.pdf</li> </ul> <p>Here you will find detailed instructions and related downloads for various ways to make your CoCo talk to a DriveWire server.</p> <p>Generalization (Review Needed)</p> <p>The following instruction has been generalized as the configuration is common across DriveWire server implementations (Java, MicroPython, etc.).</p> <p>Instructions for DriveWire 3 are generally applicable to modern DriveWire servers for all aspects of CoCo side configuration.</p>"},{"location":"Client_CoCo/#a-tale-of-too-many-roms","title":"A Tale of Too Many ROMs","text":"<p>Generalization (Review Needed)</p> <p>Simplified ROM and server terminology.</p> <p>Cloud 9 never released a \"DriveWire 4\" ROM. Modern DriveWire servers are designed to work with the Cloud 9 ROM labeled \"DriveWire 3\". Current servers are completely compatible replacements for the legacy DriveWire 3 server and do not require any changes on the CoCo side from a DriveWire 3 configuration.</p> <p>Generalization (Review Needed)</p> <p>Generalized \"DW4\" references to \"current DriveWire protocols\".</p> <p>However, since the original DriveWire protocols were created, Darren Atkinson (master hacker who created the serial routines in DW3) has developed an even better serial technique. This technique allows 230Kbps on a Coco 3 and 115.2K on a Coco 2 or Dragon. These new routines can be found in ROMs and OS9 drivers labeled \"DW4\" (referencing the protocol version), and they will only work with a compatible DriveWire server. This was not meant to imply they are required by all users. A DW3 ROM will work absolutely fine with modern DriveWire servers. A ROM using the newer \"DW4\" protocol will not work with a legacy DW3 server.</p> <p>Generalization (Review Needed)</p> <p>Generalized Becker/DW4 ROM info.</p> <p>You may also find ROMs and disks labeled \"becker\" or referring to the Becker interface. Like the improved serial \"DW4\" protocol ROMs, these will only work with a modern DriveWire server. Unlike the \"DW4\" ROMS, these are not intended for use on any traditional CoCo. Instead, these are for use in emulators (VCC and XRoar support the Becker interface) or the CoCo3FPGA board, or possibly other places where using a traditional physical bitbanging serial interface isn't ideal and/or possible.</p> <p>Generalization (Review Needed)</p> <p>Generalized legacy vs modern server comparison.</p> <p>Yet another ROM variant is the \"DW3DOS\" family. These are released by Cloud 9 and do work fine with legacy DriveWire 3 servers (and, of course, current DriveWire servers). Unlike the other ROMs mentioned here, these ROMs do not contain a variant of BASIC called HDBDOS. Instead these ROMs are designed to automatically load an OS9 style boot track at power on. Essentially these ROMS do a \"DOS\" command at boot time, so try to have a bootable disk mounted in your DriveWire server when you turn on a Coco using these ROMs.</p>"},{"location":"Client_CoCo/#summary","title":"Summary","text":"<p>If you are new to DriveWire, please use the software and instructions on the Cloud 9 site linked above.</p>"},{"location":"Client_Non_CoCo/","title":"Non-CoCo Client Software","text":"<p>(wip) </p> <p>CoCo3FPGA </p> <p>http://groups.yahoo.com/group/CoCo3FPGA/ </p> <p>Atari using Liber809 </p> <p>http://liber809.blogspot.com/ </p>"},{"location":"Config.xml/","title":"Config.xml","text":""},{"location":"Config.xml/#general","title":"General","text":""},{"location":"Config.xml/#instance","title":"Instance","text":""},{"location":"Config.xml/#drives","title":"Drives","text":""},{"location":"Config.xml/#namedobjects","title":"NamedObjects","text":""},{"location":"Config.xml/#settings","title":"Settings","text":""},{"location":"Config.xml/#debugging","title":"Debugging","text":""},{"location":"Config.xml/#device","title":"Device","text":""},{"location":"Config.xml/#detectdaturbo","title":"DetectDATurbo","text":""},{"location":"Config.xml/#devicefailretrytime","title":"DeviceFailRetryTime","text":""},{"location":"Config.xml/#serialdevice","title":"SerialDevice","text":""},{"location":"Config.xml/#serialrate","title":"SerialRate","text":""},{"location":"Config.xml/#serialparity","title":"SerialParity","text":""},{"location":"Config.xml/#serialstopbits","title":"SerialStopbits","text":""},{"location":"Config.xml/#serialflowcontrol_rtscts_in","title":"SerialFlowControl_RTSCTS_IN","text":""},{"location":"Config.xml/#serialflowcontrol_rtscts_out","title":"SerialFlowControl_RTSCTS_OUT","text":""},{"location":"Config.xml/#serialflowcontrol_xonxoff_in","title":"SerialFlowControl_XONXOFF_IN","text":""},{"location":"Config.xml/#serialflowcontrol_xonxoff_out","title":"SerialFlowControl_XONXOFF_OUT","text":""},{"location":"Config.xml/#serialdtr","title":"SerialDTR","text":""},{"location":"Config.xml/#serialrts","title":"SerialRTS","text":""},{"location":"Config.xml/#tcpaddress","title":"TCPAddress","text":""},{"location":"Config.xml/#tcpport","title":"TCPPort","text":""},{"location":"Config.xml/#midi","title":"MIDI","text":""},{"location":"Config.xml/#networking","title":"Networking","text":""},{"location":"Config.xml/#protocol","title":"Protocol","text":""},{"location":"Config.xml/#printing","title":"Printing","text":""},{"location":"Config.xml/#networking_1","title":"Networking","text":""},{"location":"Config.xml/#debugging_1","title":"Debugging","text":""},{"location":"Config.xml/#server","title":"Server","text":""},{"location":"Config.xml/#midi_1","title":"MIDI","text":""},{"location":"Config.xml/#midisynthprofile","title":"midisynthprofile","text":""},{"location":"Config.xml/#mapping","title":"mapping","text":""},{"location":"Config.xml/#logging","title":"Logging","text":""},{"location":"Config.xml/#format","title":"Format","text":""},{"location":"Config.xml/#level","title":"Level","text":"<p>Filters log entries to those ranked this level or above. </p> <p>Options (in descending verbosity) are: ALL, DEBUG, INFO, WARN, ERROR, or FATAL </p> <p>Default is WARN, which will only log items which are considered at least a potential problem. </p>"},{"location":"Config.xml/#toconsole","title":"ToConsole","text":""},{"location":"Config.xml/#tofile","title":"ToFile","text":""},{"location":"Config.xml/#file","title":"File","text":""},{"location":"Config.xml/#debugmemoryuse","title":"DebugMemoryUse","text":""},{"location":"Config.xml/#debugui","title":"DebugUI","text":""},{"location":"Configuration/","title":"Configuration","text":"<p>To configure DriveWire, choose \"Simple Config Wizard\" from the \"Config\" menu in the GUI.</p>"},{"location":"DriveWire_Specification/","title":"DriveWire Specification","text":"<p>Click here for the new home of the DriveWire specification.</p>"},{"location":"DriveWire_cables/","title":"DriveWire Cables","text":"<p>To use DriveWire, you will need a serial cable to connect your Color Computer's 4-pin DIN serial port to a modern computer (usually via a USB-to-Serial adapter).</p>"},{"location":"DriveWire_cables/#where-to-buy","title":"Where to Buy","text":"<p>You can purchase premade DriveWire cables from the following vendors:</p> <ul> <li>Cloud 9 Hardware: http://cloud9tech.com/Cloud-9/Hardware/DriveWire3.html (See the bottom of the page for cable options)</li> <li>8BitClassics: TRS-80 Color Computer 4-pin DIN to 9-pin D-Sub Serial Cable</li> </ul>"},{"location":"Getting_help/","title":"Getting Help","text":""},{"location":"Getting_help/#support","title":"Support","text":"<p>Generalization (Review Needed)</p> <p>The following section has been updated to reflect the multi-language nature of the project.</p> <p>Modern DriveWire implementations are available in several languages (Java, MicroPython, etc.). While we've done quite a bit of testing, there are certainly going to be issues that come up only as the software is tried by more people. </p> <p>You can often find other users of DW online in our IRC channel, <code>#coco_chat</code> on freenode. To join the room with your web browser, click here.</p>"},{"location":"Getting_help/#testing","title":"Testing","text":"<p>If you are interested in testing new features, see Beta Testing.</p>"},{"location":"Home/","title":"Wiki Home","text":"<p>Welcome to your wiki!</p> <p>This is the default page, edit it as you see fit. To add a new page simply reference it within brackets, e.g.: <code>[SamplePage]</code>.</p> <p>The wiki uses Markdown syntax.</p>"},{"location":"Installation/","title":"Installation","text":"<p>Generalization (Review Needed)</p> <p>The following guide has been updated to cover the general installation concepts for DriveWire server software.</p> <p>This guide covers the installation of the DriveWire server software.</p>"},{"location":"Installation/#prerequisites","title":"Prerequisites","text":"<ul> <li>Hardware: You will need a suitable cable to connect your CoCo to your PC. See DriveWire Cables.</li> <li>Client Software:<ul> <li>For CoCo: Client (CoCo) Side Software</li> <li>For Non-CoCo: Client (Non-CoCo) Side Software</li> <li>Alternative: Add DriveWire drivers to existing system</li> </ul> </li> </ul>"},{"location":"Installation/#installation_1","title":"Installation","text":"<p>Generalization (Review Needed)</p> <p>Simplified installation description.</p> <p>Installing the DriveWire server often just means unpacking an archive wherever you'd like. Most implementations do not require a formal installation program.</p>"},{"location":"Installation/#requirements","title":"Requirements","text":"<p>Generalization (Review Needed)</p> <p>Generalized requirements to indicate they are implementation-specific (primarily Java).</p> <p>The Java-based DriveWire server requires a Java JRE to be installed and working on your system. If you don't have one, you can visit java.com and follow the prompts. Other builds, such as the MicroPython version, have different requirements.</p>"},{"location":"Installation/#next-steps","title":"Next Steps","text":"<p>Once installed, proceed to Running DriveWire.</p>"},{"location":"NitrOS9_Level2_Integration/","title":"NitrOS-9 Level 2 DriveWire Integration","text":"<p>Generalization (Review Needed)</p> <p>Generalized to refer to standard DriveWire features rather than specific version 4 features.</p> <p>This guide categorizes the NitrOS-9 Level 2 modules and device descriptors used for DriveWire integration, helping you understand how the NitrOS-9 \"DriveWire\" bootfiles are constructed and how they map to DriveWire features.</p>"},{"location":"NitrOS9_Level2_Integration/#bootfiles","title":"Bootfiles","text":"<p>The NitrOS-9 Level 2 build system provides several pre-configured bootfiles. Each is tailored for a specific hardware interface or use case.</p> Bootfile Name Description Target Hardware/Use Case <code>bootfile_dw</code> Standard DriveWire support using the \"bit-banger\" serial port (6551/printer port). Stock CoCo 3, DriveWire via Serial/Bit-banger. <code>bootfile_dw_headless</code> Same as above but configured for headless operation (no VDG/GFX output). Servers, embedded use. <code>bootfile_becker</code> Uses the high-speed \"Becker\" hardware interface. CoCo3FPGA, Emulators (VCC/XRoar), Hardware Becker Interface. <code>bootfile_cocosdc</code> Boot from CoCoSDC but includes DriveWire support. Users with CoCoSDC who also want DW features. <code>bootfile_arduino</code> For DriveWire over Arduino/CoCoPort. CoCoPort interface users. <code>bootfile_cocolink</code> For the CoCoLINK interface. CoCoLINK users. <code>bootfile_rs232pak</code> For the Deluxe RS232 Pak. Deluxe RS232 Pak users. <code>bootfile_directmodempak</code> For the DirectModem Pak. DirectModem Pak users. <code>bootfile_mmmpiu1</code> MegaMiniMPI UART 1. MegaMiniMPI users (Port 1)."},{"location":"NitrOS9_Level2_Integration/#drivewire-modules","title":"DriveWire Modules","text":"<p>To use DriveWire, specific kernel modules and device descriptors must be loaded. These are automatically included in the bootfiles listed above but can also be loaded manually or customized.</p>"},{"location":"NitrOS9_Level2_Integration/#1-base-io-low-level-drivers","title":"1. Base I/O (Low-Level Drivers)","text":"<p>These modules handle the physical communication with the DriveWire server.</p> <ul> <li><code>dwio.sb</code>: The standard \"bit-banger\" driver. Uses the printer port (serial bit-banging).<ul> <li>Used in: <code>bootfile_dw</code>, <code>bootfile_dw_headless</code>.</li> </ul> </li> <li><code>dwio_becker.sb</code>: High-speed driver for the Becker interface (hardware registry mapped).<ul> <li>Used in: <code>bootfile_becker</code>.</li> </ul> </li> <li><code>dwio_arduino.sb</code>: Driver for Arduino-based interfaces (CoCoPort).</li> <li><code>dwio_rs232pak.sb</code>: Driver for the Deluxe RS232 Pak.</li> <li><code>dwio_cocolink.sb</code>: Driver for the CoCoLINK interface.</li> <li><code>dwio_directmodempak.sb</code>: Driver for the DirectModem Pak.</li> </ul>"},{"location":"NitrOS9_Level2_Integration/#2-block-devices-virtual-disks","title":"2. Block Devices (Virtual Disks)","text":"<p>DriveWire allows you to mount disk images (<code>.dsk</code>) on the server and access them as OS-9 devices.</p> <ul> <li>Driver: <code>rbdw.dr</code> (RBF driver for DriveWire).</li> <li>Device Descriptors:<ul> <li><code>x1.dd</code>, <code>x2.dd</code>, <code>x3.dd</code>: Map to DriveWire virtual drives 1, 2, and 3.</li> <li><code>ddx0.dd</code>: Maps to DriveWire virtual drive 0 (often the boot drive).</li> </ul> </li> </ul>"},{"location":"NitrOS9_Level2_Integration/#3-networking-virtual-channels-the-n-device","title":"3. Networking &amp; Virtual Channels (The <code>/N</code> Device)","text":"<p>Note: Older documentation references <code>scdwn.dr</code>. NitrOS-9 Level 2 uses the newer <code>scdwv.dr</code> (Virtual Channel Driver).</p> <ul> <li>Driver: <code>scdwv.dr</code></li> <li>Capabilities:<ul> <li>Provides virtual serial channels for TCP/IP networking, MIDI, and windowing.</li> <li>Wildcard Support: Opening the <code>/N</code> device automatically assigns the next available <code>/Nx</code> channel (e.g., <code>/N1</code>, <code>/N2</code>...<code>/N14</code>).</li> </ul> </li> <li>Device Descriptors:<ul> <li><code>n_scdwv.dd</code>: The wildcard device <code>/N</code>. Essential for networking.</li> <li><code>n1_scdwv.dd</code> - <code>n14_scdwv.dd</code>: Specific channel descriptors.</li> <li><code>midi_scdwv.dd</code>: A specific descriptor alias for MIDI applications expecting <code>/MIDI</code>.</li> </ul> </li> <li>Windowing:<ul> <li><code>z1_scdwv.dd</code>, <code>z2_scdwv.dd</code>: Map OS-9 windows to DriveWire virtual channels (useful for remote terminals).</li> </ul> </li> </ul>"},{"location":"NitrOS9_Level2_Integration/#4-printing","title":"4. Printing","text":"<p>DriveWire can emulate an OS-9 printer, capturing output to a file or passing it to a host printer.</p> <ul> <li>Driver: <code>scdwp.dr</code></li> <li>Device Descriptor: <code>p_scdwp.dd</code> (Maps to device <code>/P</code>).</li> </ul>"},{"location":"NitrOS9_Level2_Integration/#included-commands-cmds_dw","title":"Included Commands (<code>CMDS_DW</code>)","text":"<p>The NitrOS-9 Level 2 DriveWire disk (<code>NOS9_6809_L2_..._dw.dsk</code>) typically includes these utility commands in <code>/DD/CMDS</code>:</p> <ul> <li><code>dw</code>: The CLI utility to control the DriveWire server (mount disks, eject, show status).<ul> <li>Usage: <code>dw disk show</code>, <code>dw disk insert 0 mydisk.dsk</code>.</li> </ul> </li> <li><code>inetd</code>: Internet Super-Server (manages incoming network connections).</li> <li><code>telnet</code>: Telnet client for connecting to remote hosts.</li> <li><code>httpd</code>: A simple web server.</li> </ul>"},{"location":"NitrOS9_Level2_Integration/#quick-reference-booting","title":"Quick Reference: Booting","text":"<p>When you boot the <code>NOS9_6809_L2_coco3_dw.dsk</code> image:</p> <ol> <li>Kernel Loads: <code>rel_80</code>, <code>boot_dw</code>, <code>krn</code>.</li> <li>Drivers Initialize:<ul> <li><code>dwio.sb</code> starts communication.</li> <li><code>rbdw.dr</code> mounts the boot disk as <code>/DD</code>.</li> <li><code>scdwv.dr</code> initializes networking support (<code>/N</code>).</li> <li><code>scdwp.dr</code> initializes the printer (<code>/P</code>).</li> </ul> </li> <li>Startup: The <code>startup</code> file runs, setting the timezone and starting system processes. It usually includes starting <code>inetd</code> for networking services.</li> </ol>"},{"location":"NitrOS9_Level2_Integration/#troubleshooting","title":"Troubleshooting","text":"<ul> <li>\"Error #216 (Path Name Not Found)\" when trying to use <code>dw</code> or <code>telnet</code>:<ul> <li>Ensure <code>scdwv.dr</code> is loaded and <code>n_scdwv.dd</code> (device <code>/N</code>) is initialized.</li> <li>Verify you have <code>n1_scdwv.dd</code> or higher loaded so <code>/N</code> can assign a channel.</li> </ul> </li> <li>Slow Disk Access:<ul> <li>If you have a Becker interface or CoCo3FPGA, ensure you are using the <code>_becker</code> bootfile/disk image. The standard <code>_dw</code> image uses bit-banging which is significantly slower.</li> </ul> </li> </ul>"},{"location":"OS9_Modules/","title":"OS-9 Modules","text":""},{"location":"OS9_Modules/#intro","title":"Intro","text":"<p>If you'd like to add DriveWire functionality to your existing OS-9 system, you'll need to load various modules depending on which features you'd like to use.</p> <p>Premade NitrOS-9 boot disks with all the modules included are available from the NitrOS-9 project.</p> <p>The DriveWire modules are included in the NitrOS-9 source code if you'd like to build them yourself. For specific details on NitrOS-9 Level 2 integration, please see NitrOS9 Level 2 Integration.</p>"},{"location":"OS9_Modules/#modules","title":"Modules","text":""},{"location":"OS9_Modules/#base-io","title":"Base I/O","text":"<p>The I/O routines for all DriveWire functionality are contained in the dwio module. The stock dwio module is called dwio.sb. This module uses the bit banger for it's I/O. You can use alternate dwio modules if you'd like to use another device. In the NitrOS9 CVS you will find dw3_becker.sb which enables high speed functionality in Gary Becker's Coco3FPGA project, and dw3_mess.sb which is used with John Linville's MESS patch. </p> <p>Generalization (Review Needed)</p> <p>The following TODO has been generalized to refer to enhanced serial protocols rather than just \"DW4\".</p> <p>TODO - find the dwsub for 6551 TODO - document enhanced \"Turbo\" I/O protocols.</p> <p>You must load one dwio module in order to use any DriveWire functionality. </p>"},{"location":"OS9_Modules/#disk-devices","title":"Disk Devices","text":"<p>The driver for RBF disk devices is rbdw.dr</p> <p>This module is required if you'd like to access disk images as RBF devices. You must also load one or more device descriptors corresponding to the drives you would like to have available. These are x0.dd - x255.dd, you can load any combination. If you'd like /DD to be on drivewire, use the ddx0.dd descriptor. </p>"},{"location":"OS9_Modules/#printing","title":"Printing","text":"<p>To use DriveWire printing, load the driver scdwp.dr and the descriptor p_scdwp.dd. This will add the device /p to your system, which delivers anything sent to it to the DriveWire virtual printer. </p>"},{"location":"OS9_Modules/#virtual-serial-ports","title":"Virtual Serial Ports","text":"<p>The driver for all virtual serial port functionality, including virtual modems and TCP/IP networking, is scdwn.dr. The device descriptors for virtual serial ports work a little differently than typical OS9 devices. You'll need the pseudo device /N, which is loaded using the descriptor n_scdwn.dd, and also one or more channel descriptors, n1_scdwn.dd through n14_scdwn.dd. Channel descriptors must be sequential, starting with 1, but you may include as many or as few as you would like. </p> <p>When a program opens the /N device, it is returned a path to the next free channel from the channel descriptors you have loaded. This way you can do several things with the virtual ports without needing to worry about allocating them specifically to any given task. When a program closes the /Nx device it is returned to the pool of available channels. </p> <p>The 'dw' command requires the /N device and at least one /Nx device to be loaded. </p>"},{"location":"OS9_Modules/#remote-term-device","title":"Remote TERM Device","text":"<p>If you'd like to put the OS9 TERM device on a virtual channel (so it can be accessed via telnet), load the term_scdwn.dt descriptor in place of your regular term descriptor. scdwn.dr is a requirement for this feature. By putting TERM on a DriveWire virtual device, you can remove vtio, vdgint, cowin and all of the window descriptors, which will free a large amount of system RAM for other purposes. </p>"},{"location":"OS9_Modules/#midi","title":"MIDI","text":"<p>MIDI uses a virtual serial channel and requires the same driver module, scdwn.dr. If your MIDI program allows you to specify /N as the MIDI device, you don't need anything special to use MIDI. Some MIDI players only allow the device to be called /MIDI. To support these programs, you can load the device descriptor midi_scdwn.dd in place of the 14th channel descriptor n14_scdwn.dd. Do not try to load n14_scdwn.dd and midi_scdwn.dd at the same time. </p> <p>Although you should load the nX devices sequentially, meaning n13_scdwn.dd should be used if n14_scdwn.dd is used, this is not a requirement for using midi_scdwn.dd. You can use midi_scdwn without any /N devices, or with any number of them. </p>"},{"location":"Solving_low_memory_issues/","title":"Troubleshooting Memory","text":"<p>If you see a warning stating that DriveWire must disable some functions due to lack of free memory, or worse an error dialog stating \"java.lang.OutOfMemoryError....\", the info on this page will help you make DriveWire happy again. </p> <p>**First of all... don't panic. You are not out of RAM. Your system is fine. **</p> <p>Generalization (Review Needed)</p> <p>The following section has been updated to clarify that memory limits are implementation-specific (primarily Java).</p> <p>You probably just need to make a small adjustment to the amount of RAM your operating system allows the DriveWire server to use. Java-based builds are a little different than native programs; they cannot simply request any given amount of memory from the operating system as needed. Instead, the Java Virtual Machine imposes a strict limit on the amount of RAM any one Java application can use. The exact amount allowed by default can vary greatly and since DriveWire runs on a wide variety of platforms, sometimes we need a bit more than we are given. </p> <p>If you are running the full GUI, a safe estimate for required RAM is 20MB + (the size of the largest disk you plan to mount), with an upper limit of 128MB total. DriveWire will not use any RAM it does not need regardless of how much you allocate, but it will use RAM for caching and other performance improvements if there is extra available. </p> <p>So... DriveWire is running out of memory, and we know it's something that can be adjusted.. OK, how? </p> <p>And the answer is: It depends! </p> <p>All platforms can specify memory size on the command line. To do this, you add the argument -Xmx followed by the RAM you wish to allow, for instance -Xmx256m would allow 256mb, and -Xmx512m would allow 512mb (probably way more than DW needs). </p> <p>Generalization (Review Needed)</p> <p>References to \"DW4\" have been generalized to the Java build of DriveWire.</p> <p>The entire command to start the Java-based DriveWire server would then look like: </p> <p><code>java -Xmx128m -jar DriveWire.jar</code></p> <p>on every system except Macs... Macs are special and require one additional argument (whether or not you are specifying a RAM allocation): </p> <p>Generalization (Review Needed)</p> <p>Updated scripts and launcher names to be more generic.</p> <p><code>java -Xmx256m **-XstartOnFirstThread** -jar DriveWire.jar</code> </p> <p>For Linux or Mac users who already launch DriveWire via scripts, you can edit your script to include this argument and you're good to go. </p> <p>For Windows we include a launcher, which is convenient but also prevents adding a command line argument easily. You can either create a .bat file with the command above in it and use that to launch the DriveWire server, or you can configure your system wide Java memory default to be more generous. To do the later, see this article. (You can also change the system wide default on a Linux or Mac system, but that is left as an exercise for the reader). </p>"},{"location":"The_%27dw%27_commands/","title":"Command Reference","text":"<ul> <li>dw<ul> <li>Examples</li> <li>dw disk<ul> <li>dw disk show</li> </ul> </li> <li>Examples<ul> <li>dw disk eject</li> </ul> </li> <li>Examples<ul> <li>dw disk insert</li> </ul> </li> <li>Examples<ul> <li>dw disk reload</li> </ul> </li> <li>Example<ul> <li>dw disk write</li> </ul> </li> <li>Examples<ul> <li>dw disk create</li> </ul> </li> <li>Examples<ul> <li>dw disk set</li> </ul> </li> <li>Examples</li> <li>dw port</li> <li>dw net</li> <li>dw server</li> <li>dw config</li> <li>dw log</li> <li>dw midi</li> </ul> </li> </ul>"},{"location":"The_%27dw%27_commands/#dw","title":"dw","text":"<p>Usage: <code>dw [command]</code> </p> <p>The various 'dw' commands allow you to control and configure every aspect of the server. These commands can be sent to the server in a number of ways, including the dw command utility in OS9 or the DriveWire User Interface graphical tool. </p> <p>All commands may be abbreviated to their shortest unique form. For help on any dw command, enter the portion you know followed by\u00a0?. </p>"},{"location":"The_%27dw%27_commands/#examples","title":"Examples","text":"<pre><code>dw disk ?        # show help for 'dw disk'\ndw d sh          # abbreviated form of 'dw disk show'\n</code></pre>"},{"location":"The_%27dw%27_commands/#dw-disk","title":"dw disk","text":"<p>Usage: <code>dw disk [command]</code> </p> <p>The dw disk commands allow you to manage the DriveWire virtual drives. </p>"},{"location":"The_%27dw%27_commands/#dw-disk-show","title":"dw disk show","text":"<p>Usage: <code>dw disk show [{# | all | dset [#]}]</code> </p> <p>Show current disk/set details </p> <p>Generalization (Review Needed)</p> <p>Generalized \"DW4\" to \"the DriveWire server\".</p> <p>The dw disk show command is a useful tool for quickly determining the status of the many virtual disk drives that the DriveWire server provides. It can be abbreviated as \"dw d sh\". </p>"},{"location":"The_%27dw%27_commands/#examples_1","title":"Examples","text":"<pre><code>dw disk sh          # show overview of the currently loaded drives\ndw disk sh 0        # show details about disk in drive 0\ndw disk sh all      # show all available disksets\ndw disk sh myset    # show overview of the diskset 'myset'\ndw disk sh myset 0  # show details about disk 0 in 'myset'\n</code></pre>"},{"location":"The_%27dw%27_commands/#dw-disk-eject","title":"dw disk eject","text":"<p>Usage: <code>dw disk eject [dset] {# | all}</code> </p> <p>Eject disk from drive # </p> <p>This command lets you eject disk images from the virtual drives, or remove disk definitions from disk sets. The special word 'all' may be used in place of a drive number to eject all disks. </p>"},{"location":"The_%27dw%27_commands/#examples_2","title":"Examples","text":"<pre><code>dw disk eject 1        # eject disk from virtual drive 1\ndw disk eject myset 1  # remove disk definition 1 from set myset\ndw disk eject all      # unload all virtual drives\ndw d e myset all       # clear all definitions from set myset\n</code></pre>"},{"location":"The_%27dw%27_commands/#dw-disk-insert","title":"dw disk insert","text":"<p>Usage: <code>dw disk insert [dset] # path</code> </p> <p>Load disk into drive # </p> <p>The disk insert command is used to load a disk image into the virtual drives or to add a disk definition to a diskset. The path argument can be either a local file path or a URI. See the wiki information on paths for more details. </p>"},{"location":"The_%27dw%27_commands/#examples_3","title":"Examples","text":"<pre><code>dw disk insert 0 c:\\cocodisks\\mydisk.dsk  # load disk into drive 0\ndw d i myset 5 ftp://site.com/nitros9.dsk # add disk definition to myset\n</code></pre>"},{"location":"The_%27dw%27_commands/#dw-disk-reload","title":"dw disk reload","text":"<p>Usage: <code>dw disk reload {# | all}</code> </p> <p>Reload disk in drive # </p> <p>This command tells the server to reload a buffer from it's current source path. This will overwrite any unsaved changes in the buffer. </p>"},{"location":"The_%27dw%27_commands/#example","title":"Example","text":"<pre><code>dw d reload 5  # reload disk image for drive 5\n</code></pre>"},{"location":"The_%27dw%27_commands/#dw-disk-write","title":"dw disk write","text":"<p>Usage: <code>dw disk write {# [path] | dset [dset]}</code> </p> <p>Write disk images and disksets </p> <p>The dw disk write command can do a handful of different operations depending on the arguments you provide. In the simplest form, it will write a drive's current buffer contents back to the source path. You can specify a different path if you'd like to write the buffer to somewhere else. If you specify a diskset name instead of a drive number, the server will write definitions of the currently loaded disks into the named set. Specifying two diskset names will tell the server to write one diskset to another, creating the destination set if it does not exist. </p>"},{"location":"The_%27dw%27_commands/#examples_4","title":"Examples","text":"<pre><code>dw disk write 9                 # write buffer for drive 9 to the source path\ndw d w 9 /home/coco/backup1.dsk # write drive 9 buffer to an alternate path\ndw disk write myset             # write current drives to diskset myset\ndw disk write myset newset      # copy definitions in myset to newset \n</code></pre>"},{"location":"The_%27dw%27_commands/#dw-disk-create","title":"dw disk create","text":"<p>Usage: <code>dw disk create {# path | dset}</code> </p> <p>Create new disk image or set </p> <p>This command will create a new disk image (0 byte file) at the specified path and mount it in the specified drive, or create a new blank disk definition with the specified name. </p>"},{"location":"The_%27dw%27_commands/#examples_5","title":"Examples","text":"<pre><code>dw disk create mynewset      # create new diskset 'mynewset'\ndw d c 0 c:\\coco\\newdisk.dsk # create new .dsk in drive 0\n</code></pre>"},{"location":"The_%27dw%27_commands/#dw-disk-set","title":"dw disk set","text":"<p>Usage: <code>dw disk set {dset [#] | #} param [val]</code> </p> <p>Set disk/diskset parameters </p> <p>The disk set command allows you to set or unset a variety of parameters on disks, disksets, and disk definitions inside a disk set. For information on the various parameters available, see the relevant wiki topic. </p>"},{"location":"The_%27dw%27_commands/#examples_6","title":"Examples","text":"<pre><code>dw d set 1 writeprotect true     # Enable an option for disk loaded in drive 1\ndw d set myset SaveChanges false # Disable an option for the diskset 'myset'.\ndw d set myset 1 sizelimit       # Unset a paramter on disk def 1 in 'myset'.\n</code></pre>"},{"location":"The_%27dw%27_commands/#dw-port","title":"dw port","text":"<pre><code>  dw port show                - Show current port status\n  dw port close #             - Force port # to close\n</code></pre>"},{"location":"The_%27dw%27_commands/#dw-net","title":"dw net","text":"<pre><code>dw net show\ndw net close #\n</code></pre>"},{"location":"The_%27dw%27_commands/#dw-server","title":"dw server","text":"<pre><code>dw server show              # Show server status\ndw server show threads      # Show server threads\ndw server show handlers     # Show server handler instances\ndw server show config       # Show server level configuration\ndw server dir [filepath]    # Show directory on server\ndw server list [filepath]   # List file on server\ndw server makepass [text]   # Return encrypted form of text (use with auth)\n</code></pre>"},{"location":"The_%27dw%27_commands/#dw-config","title":"dw config","text":"<pre><code>dw config show              # Show current configuration\ndw config show [key]        # Show current value for key\ndw config set [key] [value] # Set config item key = value\ndw config save              # Save current configuration to disk\ndw config load              # Load configuration from disk\n</code></pre>"},{"location":"The_%27dw%27_commands/#dw-log","title":"dw log","text":"<pre><code>dw log show    # Show last 20 log lines\ndw log show #  # Show last # log lines\n</code></pre>"},{"location":"The_%27dw%27_commands/#dw-midi","title":"dw midi","text":"<pre><code>dw midi show                  # Show midi status\ndw midi output #              # Set midi output to device #\ndw midi synth show            # Show internal synth status\ndw midi synth show channels   # Show internal synth channel status\ndw midi synth show instr      # Show available instruments\ndw midi synth show profiles   # Show available sound translation profiles\ndw midi synth bank [filepath] # Load soundbank file\ndw midi synth profile [name]  # Load sound tranlastion profile\ndw midi synth instr lock      # Toggle instrument lock (ignore program changes)\ndw midi synth instr [#x] [#y] # Set channel X to instrument Y\n</code></pre>"},{"location":"The_DriveWire_GUI/","title":"GUI Manual","text":"<p>Generalization (Review Needed)</p> <p>The following describes the Java-based graphical interface. Other implementations (like MicroPython) may use different configuration methods.</p> <p>The DriveWire Java GUI is a special client designed to allow you to configure the DriveWire server. It contains menus and buttons that simplify and speed up issuing commands to the server. It also allows you to create and maintain Disk sets and load virtual disks (or real floppy drives) for the Color Computer to use. To learn more about the commands in DriveWire, see Using_DriveWire. </p> <ul> <li>Server Console</li> <li>DriveWire User Interface</li> <li>Menus<ul> <li>File Menu</li> <li>Tools Menu</li> <li>MIDI Menu</li> <li>Config Menu</li> <li>Help Menu</li> </ul> </li> </ul>"},{"location":"The_DriveWire_GUI/#server-console","title":"Server Console","text":"<p>(Image:Server.PNG) </p> <p>When you double-click Go.cmd, the Server Console window is the first thing you will see. If \"Log to Console\" is enabled in the server settings dialog, this window will contain information about the server activity, including error reports, connections, disconnections, etc. The detail level and format of information can be adjusted in the server settings dialog. </p> <p>By closing this window, you will terminate the server. You can minimize the server window if viewing is not required. </p> <p>See Using_DriveWire#Introduction </p> <p>Generalization (Review Needed)</p> <p>Generalized heading to \"DriveWire User Interface\".</p> <p>(Image:Client.PNG) </p> <p>This is the main window and interface with the server, referred to as the client. Through it you mount disks in drive slots, create Diskset lists, and control the functions of DriveWire. Most of the buttons and menu items are merely shortcuts to build DriveWire commands. Alternatively, you can type in a DriveWire command in the command line box at the bottom of the window. </p> <p>Title Bar</p> <p>The numbers on the right of the window title indicate: </p> <p>127.0.0.1  the current IP address of the client </p> <p>6800  the port </p> <p><code>[0]</code>  the instance number </p> <p>See Using_DriveWire#Introduction for more on instances. </p> <p>Menu Bar</p> <p>The menu bar contains the following menus: </p> <ul> <li>#File_Menu </li> <li>#Tools_Menu </li> <li>#MIDI_Menu </li> <li>#Config_Menu </li> <li>#Help_Menu </li> </ul> <p>See #Menus below. </p> <p>Button Bar</p> <p>The button bar is divided into three groups, Diskset, Virtual Drives, and Server Status. </p> <p>Diskset:</p> <ol> <li>Refresh Disks - refreshes the current list </li> <li>Load Diskset - loads a new diskset </li> <li>Save Diskset - saves the current diskset </li> </ol> <p>For more information on disksets, see Using_DriveWire#Disk_Sets. </p> <p>Virtual Drives:</p> <p>X0-X3 - represent the 4 most frequently used drives. Each button builds the command: </p> <pre><code>dw insert # URI/Path\n</code></pre> <p>where # is drive slot 0, 1, 2, or 3, and the URI/Path is supplied by the file selected in the open dialog provided. The selected file is inserted into the slot indicated by the number of the button. </p> <p>View Status</p> <p>Opens a dialog window that displays useful information about the server. </p> <p>Disk Section</p> <p>Below the button bar is the disk section, with the disk list on the left, and disk information on the right. </p> <p>Disk List</p> <p>The disk list is a list of slots, where disks and disksets are inserted. You can add up to 256 disks to the list (0-255). </p> <p>Disks and disksets are added with the buttons on the button bar, or loaded in the URI/Path box in the disk information area, by selecting a drive slot in the list, locating the disk image and clicking the Apply button. </p> <p>Disk Information</p> <p>If you click on a disk slot in the list, the information for that disk is displayed. When you select a disk from the list, The text \"Select a drive from the list on the left to display details\" is replaced with \"Disk n URI:\", where n is the number of the drive slot selected. The box below contains the URI. To the right of the URI is a button which opens a find dialog so you can locate a disk image file to load locally. Clicking Apply will insert that disk image into the selected disk slot. </p> <p>Available information on the disks includes: </p> <p>Check-boxes:Default:Description: </p> <p>Write protect unchecked blocks changes from the coco to the buffer if checked </p> <p>Sync\u00a0changes\u00a0to\u00a0source checked blocks changes from the buffer to the source if checked </p> <p>Allow expansion checked allows automatic expansion of a file when you write past end of file if checked, otherwise going past the size of the file will result in an error 211 on the CoCo </p> <p>Text-boxes:Default:Description: </p> <p>Size limit (sectors): -1 limits file size to the specified number of sectors, -1 = unlimited </p> <p>Offset (sectors): 0 need to ask what this is </p> <p>Sector InformationDefault:Description: </p> <p>Total Sectors: 0 total number of sectors on the disk </p> <p>Current LSN: 0 current LSN of the file pointer </p> <p>Access InformationDefault:Description: </p> <p>Reads: 0 number of reads from this disk </p> <p>Writes: 0 number of writes to this disk </p> <p>Dirty sectors: 0 need to ask what this is </p> <p>Other InformationDescription: </p> <p>Filesystem is writeable gray if the disk is not writable </p> <p>File is writeable gray if the file is not writable, filesystem must be writable </p> <p>File is random writeable gray if the file is not random writable, file must be writable </p> <p>ButtonsDescription: </p> <p>Eject Eject disk from the currently selected slot </p> <p>Write to... Write currently selected disk to alternate location </p> <p>Reload Reload the disk in the currently selected slot </p> <p>Refresh Refresh the disk list </p> <p>Apply Apply changes to the disk in the currently selected slot </p> <p>See Using_DriveWire for more information. </p> <p>Server Information Box</p> <p>Below the disk list is the server information box. When the server returns information in response to a command, it appears in this box. For example, server status messages are returned here. </p> <p>Command Line</p> <p>At the bottom of the window is the command line. Here you can type any valid DriveWire command. Pressing <code>[ENTER]</code> sends the command to the server. </p> <p>For more details on DriveWire commands, see Using_DriveWire#The_'dw'_command. </p>"},{"location":"The_DriveWire_GUI/#drivewire-user-interface","title":"DriveWire User Interface","text":""},{"location":"The_DriveWire_GUI/#menus","title":"Menus","text":""},{"location":"The_DriveWire_GUI/#file-menu","title":"File Menu","text":"<p>(Image:FileMenu.PNG) </p> <p>Choose Server... Dialog</p> <p>(Image:ChooseServer.PNG) </p> <pre><code>I am unclear on this. The dialog contains a droplist.\nI assume this means multiple-server support.\nThe user can switch to a different server.\n\nQuestions are:\n\n1 Is there a limit to the number of servers in the list?\n2 What impact does choosing a different server have on the current configuration?\n3 Does anything in the config.xml file get changed?\n\nEntering the server 127.0.1.1:6800 resulted in:\n\nA 127.0.1.1:6800 being added to the droplist in the choose server dialog\nB Nothing reported in the server information box\nC Nothing being reported in the server console window\nD The window title bar for the client changed to reflect server 127.0.1.1:6800\n\nI assume B and C are because there is no server at that address.\nShould the client report no server found?\n</code></pre> <p>Choose Instance... Dialog</p> <p>(Image:ChooseInstance.PNG) </p> <p>Exit</p>"},{"location":"The_DriveWire_GUI/#tools-menu","title":"Tools Menu","text":"<p>(Image:ToolsMenu.PNG) </p> <p>Diskset properties...</p> <p>Create dsk...</p> <p>.dsk &amp;lt;-&amp;gt; disk Submenu</p> <p>(Image:dskMenu.PNG) </p> <p>Copy .dsk to floppy disk</p> <p>Copy floppy disk to .dsk</p> <p>Create .DSK from floppy disk Dialog</p> <p>(Image:CreateDSK.PNG) </p> <p>This wizard is incomplete. </p> <p>HDBDOS Submenu</p> <p>(Image:HBDDOSmenu.PNG) </p> <p>HDBDOS translation Submenu</p> <p>(Image:HBDDOStranslationMenu.PNG) </p> <p>Create diskset Submenu</p> <p>(Image:HBDDOScreateDisksetMenu.PNG) </p> <p>Server status</p> <p>Show server Submenu</p> <p>(Image:ShowServerMenu.PNG) </p> <p>Log Viewer Window</p> <p>(Image:LogViewer.PNG) </p>"},{"location":"The_DriveWire_GUI/#midi-menu","title":"MIDI Menu","text":"<p>(Image:MIDImenu.PNG) </p> <p>Show Status</p> <p>Set output...</p> <p>Choose MIDI Output Device... Dialog</p> <p>(Image:ChooseMIDIoutput.PNG) </p> <p>Choose MIDI Output Device... Droplist</p> <p>(Image:ChooseMIDIdroplist.PNG) </p> <p>Synth Submenu</p> <p>(Image:SynthMenu.PNG) </p> <p>Show status</p> <p>Show Submenu</p> <p>(Image:ShowMenu.PNG) </p> <p>Load soundbank...</p> <p>Set profile...</p> <p>Choose Translation Profile... Dialog</p> <p>(Image:ChooseTranslationProfile.PNG) </p> <p>Choose Translation Profile... Droplist</p> <p>(Image:ChooseTranslationDroplist.PNG) </p> <p>Lock instruments...</p>"},{"location":"The_DriveWire_GUI/#config-menu","title":"Config Menu","text":"<p>(Image:ConfigMenu.PNG) </p> <p>Simple Config...</p> <p>Initial Configuration Wizard</p> <p>(Image:SimpleConfigWizard.PNG) </p> <p>(Image:SimpleWizard2.PNG) </p> <p>(Image:SimpleWizard3.PNG) </p> <p>(Image:SimpleWizard4.PNG) </p> <p>Server...</p> <p>Server Configuration Dialog</p> <p>(Image:ServerConfig.PNG) </p> <p>Instance...</p> <p>Instance Configuration Dialog</p> <p>(Image:InstanceConfigCon.PNG) </p> <p>(Image:InstanceConfigDev.PNG) </p> <p>(Image:InstanceConfigNet.PNG) </p> <p>(Image:InstanceConfigIP.PNG) </p> <p>(Image:InstanceConfigAdv.PNG) </p> <p>User Interface...</p> <p>User Interface Configuration Dialog</p> <p>(Image:UIconfig.PNG) </p> <p>Reset Instance Device</p>"},{"location":"The_DriveWire_GUI/#help-menu","title":"Help Menu","text":"<p>(Image:HelpMenu.PNG) </p> <p>Documentation</p> <p>About...</p> <p>(Image:About.PNG) </p>"},{"location":"Using_DriveWire/","title":"Using DriveWire","text":""},{"location":"Using_DriveWire/#introduction","title":"Introduction","text":"<p>DriveWire provides many services to your CoCo. These include disk drives that can mount disk image files, serial ports that can be used to communicate over the internet, a real time clock, MIDI, and printing support.</p>"},{"location":"Using_DriveWire/#instances","title":"Instances","text":"<p>Generalization (Review Needed)</p> <p>Generalized server and GUI terminology.</p> <p>The DriveWire server can provide any number of instances. Each instance supports one CoCo via one connection, such as a serial link or TCP/IP connection. A single server can run one or many instances at the same time. Each instance has its own set of virtual disks, ports, etc. Instances can be started and stopped using <code>dw</code> commands or across implementations using tools like the Instance Manager in the Java GUI.</p> <p>(Image: drivewireserver block.jpg)</p> <p>Generalization (Review Needed)</p> <p>Generalized GUI name.</p> <p>There are multiple interfaces which can be used to configure and control these services. The most basic tool for these tasks is the OS-9 command <code>dw</code> which comes on a DriveWire bootable NitrOS-9 image and can be found in the DriveWire CVS repository in source form. If you prefer to manage DriveWire from a PC, you can use the Java-based User Interface, a GUI that runs on modern computers.</p>"},{"location":"Using_DriveWire/#starting-the-drivewire-server-and-gui","title":"Starting the DriveWire Server and GUI","text":"<p>Generalization (Review Needed)</p> <p>The following section on the Java GUI has been flagged for generalization.</p> <p>To start the Java-based DriveWire server from a GUI, double click on the launcher file most likely to work on your system:</p> <ul> <li>Windows: <code>DriveWire.exe</code> or <code>DriveWire.jar</code></li> <li>macOS: <code>DriveWire.command</code></li> <li>Linux/BSD: <code>DriveWire.sh</code></li> </ul> <p>Generalization (Review Needed)</p> <p>Updated launch instructions to be more generic.</p> <p>On all systems except macOS, change to the directory where you unzipped the DriveWire package, and enter:</p> <pre><code>java -jar DriveWire.jar\n</code></pre> <p>On Mac OS X (think different, I guess), instead enter: </p> <p>java -XstartOnFirstThread -jar DriveWire.jar </p> <p>For additional debugging info that may be helpful, try: </p> <p>java -jar DriveWire.jar --debug </p> <p>or </p> <p>java -jar DriveWire.jar --logviewer </p> <p>or </p> <p>java -jar DriveWire.jar --help </p> <p>for more options. </p>"},{"location":"Using_DriveWire/#starting-only-the-server","title":"Starting only the server","text":"<p>java -jar DriveWire.jar --noui </p>"},{"location":"Using_DriveWire/#starting-only-the-gui","title":"Starting only the GUI","text":"<p>java -jar DriveWire.jar --nogui </p>"},{"location":"Using_DriveWire/#starting-the-lite-ui","title":"Starting the Lite UI","text":"<p>java -jar DriveWire.jar --liteui </p>"},{"location":"Using_DriveWire/#disk-buffers","title":"Disk Buffers","text":"<p>When you insert a disk into one of DriveWire's drives, the contents of the source image are read into a buffer. All reads and writes done from the CoCo operate on the buffer contents, not directly on the source. This is similar to how applications such as word processors work: you load a file into the word processor and make changes to an in memory copy of the document. </p> <p>Similar to a word processor's \"auto save\" function, DriveWire will periodically write any changes made to the buffer back to the source in some situations. You can load a disk image from a wide variety of sources, and some are not writable or do not support random access operations. If DriveWire cannot do random access writes to the source, you will have to use the 'dw disk write' or the equivalent \"Write to..\" function in the GUI to save any changes you make to the buffer. The \"Write to..\" function writes the entire buffer and so can support sources that are not random writable such as WebDAV and FTP servers. </p> <p>This diagram displays how the various disk settings effect the operation of the buffers. These settings can be specified using the GUI, using various 'dw disk' commands, or stored along with a source path in a disk set. </p> <p>(Image: dw_buffer.gif) </p>"},{"location":"Using_DriveWire/#the-dw-command","title":"The 'dw' command","text":"<p>The 'dw' utility runs in OS9, it can be found on the latest NitrOS9 disks for DriveWire. The sub commands and options available in dw provide many informational displays and give you a way to configure every aspect of DriveWire operation right from your CoCo. </p> <p>Generalization (Review Needed)</p> <p>Generalized GUI command box reference.</p> <p>You can also issue any dw command from the Java GUI using the command box at the bottom of the main form. </p> <p>All of the sub commands and options to dw may be abbreviated to their shortest unique form. For example, the command \"dw server show threads\" can be given as \"dw s s t\". </p> <p>For quick help on what sub commands are available, type \"dw\" by itself. For help on an individual sub command, type \"dw subcommand\", for instance \"dw disk\". </p>"},{"location":"Using_DriveWire/#hdbdosmode","title":"HDBDOSMode","text":"<p>HDBDOS for DriveWire allows access to DriveWire disks under DECB. </p> <p>In DriveWire 3, DriveWire disks 0 - 3 are treated as a virtual hard drive containing 256 disk images. You can communicate with only one of these virtual hard drives at a time, switching between them using the command \"DRIVE #x\". Within these large files you access the 256 individual disks with the standard DRIVE command. </p> <p>Generalization (Review Needed)</p> <p>Generalized DriveWire behavior.</p> <p>DriveWire defaults to identical behavior. </p> <p>DW3/Default mode:</p> <p>(Image: hdbdos_dw3.gif) </p> <p>Generalization (Review Needed)</p> <p>Generalized HDBDOS mode comparison.</p> <p>The way DriveWire 3 and HDBDOS work together makes it difficult to do some common tasks. There is no way to copy data between two different .dsk files, for instance. To make these tasks easier, modern DriveWire servers have an alternate mode that can be enabled by specifying: </p> <p>&lt;HDBDOSMode&gt;true&lt;/HDBDOSMode&gt;</p> <p>inside any instance section or diskset definition. You can also toggle this mode on and off using the DriveWire user interface. </p> <p>HDBDOSMode uses the sector number contained in each request sent from HDBDOS, and not the drive number, to determine which .dsk file to access. The result is a one to one mapping between disks on the CoCo and disks in DriveWire. The \"DRIVE #\" command has no effect when DriveWire is in this mode. </p> <p>HDBDOSMode:</p> <p>(Image: hdbdos_dw.jpg) </p>"},{"location":"Using_DriveWire/#copying-disks-between-real-floppies-and-drivewire-disks","title":"Copying disks between real floppies and DriveWire disks","text":"<p>HDBDOS allows you to access real floppy drives using the DRIVE OFF command. This will allow access to real drives 0-3 and still provide DriveWire drives 4-255. When in HDBDOSMode, you can then copy (for instance) a real floppy in drive 0 to a DriveWire disk in drive 4 using a command like: </p> <p><code>BACKUP 0 To 4</code></p> <p>To write a .dsk image to a real floppy, use: </p> <p><code>BACKUP 4 to 0</code></p>"},{"location":"Using_DriveWire/#using-dw3-style-files-containing-multiple-floppy-images","title":"Using DW3 style files containing multiple floppy images","text":"<p>Generalization (Review Needed)</p> <p>Generalized multi-disk image support.</p> <p>If you have existing 'hard disk' images, containing 256 floppies in a single file, you can still use them in current DriveWire servers. In fact, you can do some things with them that were impossible in legacy versions. </p> <p>The simplest way to use these types of images is to leave HDBDOS mode turned off. Current DriveWire servers will behave exactly like DW3 did in this mode, and you can use the multi-disk images as you always have. </p> <p>However, you can now copy between disk images, something that was impossible in DW3. You can also mount a single disk or set of disks out of one image and other disks from another image, or mix some single disk images with a multi disk image. The key to doing all of this is the new HDBDOS mode, combined with the sector offset setting. </p> <p>When in HDBDOS mode, the server ignores the drive # sent in I/O requests and instead uses the absolute sector of the request to determine which server drive will handle it. This means that you can load a regular single disk .dsk image into any of the 256 drives, and access it from the coco simply as that same drive. To copy between two single disk image files, simply mount each in a different drive # and copy as usual. </p> <p>Generalization (Review Needed)</p> <p>Generalized multi-disk image handling.</p> <p>To move files between multi-disk images is a bit more complicated, but it's quite easy once you get the hang of it. The multi-disk images contain up to 256 disk images, each containing exactly 630 sectors. We can use the sector offset setting to map any of those individual disks to any of the DriveWire server's drives, and then again we access these as the same drive # on the CoCo. </p> <p>For instance, lets say you have 2 DW3 style multi disk images, multiA.dsk and multiB.dsk. You want to copy a file from disk #10 in multiA.dsk to disk #20 in multiB.dsk. </p> <p>Since every disk is exactly 630 sectors, we know that disk #10 starts at sector 6300 of the file multiA.dsk. We can insert multiA.dsk into any DriveWire server drive and specify an offset of 6300 (This can be done in the GUI or using the 'dw' command in OS9, and can be changed at any time while the disk is inserted. You can also store an offset along with other disk details in disk sets). Similarly we would insert multiB.dsk and give an offset of 12600, so that it points to disk #20. Now we can copy directly between the two. </p> <p>You can also mount different disk images that are inside the same multi disk image. Just insert the file into more than one drive, specifying a different offset on each one. You can use this technique to rearrange the disks inside the file to fit into any drives you'd prefer, or to create a system that uses some disks out of one image and other disks out of another (or several). </p> <p>You can also use offsets to access files containing partitions, especially partitions that do not start at the beginning of an image. When doing complex configurations with offsets outside of HDBDOS mode (which enforces size limits per disk by its very nature), you may want to use the size limit setting to ensure no writes go beyond the region of the file you want to work with. Read/Writes to sectors greater than the offset + the limit specified will return errors even if the sector exists in the underlying file. </p>"},{"location":"Using_DriveWire/#use-with-cocoboot","title":"Use with CoCoBoot","text":"<p>There are a few options that can be specified in config.xml for use specifically with CoCoBoot. These cannot currently be configured from the GUI, although an updated GUI will be available soon that can manage them. All of these settings should be specified in the &lt;Instance&gt; section(s) you wish them to effect. </p> <p>Generalization (Review Needed)</p> <p>Generalized path rules.</p> <p>NamedObjectDir sets a path to use for named object mount requests. CoCoBoot uses these requests to load scripts and save data. You can specify any valid local path or URL, following the same rules as any disk path or other file setting in DriveWire. Example: </p> <p>&lt;NamedObjectDir&gt;E:\\cocodisks\\named&lt;/NamedObjectDir&gt;</p> <p>If you would like named objects to reload when the server notices a change in the original source object, enable NamedObjectSyncFromSource: </p> <p>&lt;NamedObjectSyncFromSource&gt;true&lt;/NamedObjectSyncFromSource&gt;</p> <p>If you are using the default 40 column mode in CoCoBoot, the dw command help will wrap and use a lot of screen real estate. You can turn off the extra help: </p> <p>&lt;CommandShortHelp&gt;false&lt;/CommandShortHelp&gt;</p> <p>Generalization (Review Needed)</p> <p>Generalized file padding behavior.</p> <p>Often you will want to create CoCoBoot scripts using your own editor on modern PC and load them into CoCoBoot via DriveWire. Normally the server will complain about images that are not some multiple of 256 bytes in size. This setting will tell the server to simply pad files out to fill the last sector with 0 (Which CoCoBoot understands). </p> <p>&lt;DiskPadPartialSectors&gt;true&lt;/DiskPadPartialSectors&gt;</p>"},{"location":"Using_DriveWire/#paths","title":"Paths","text":"<p>Generalization (Review Needed)</p> <p>Generalized VFS library dependence (specific to Java implementation).</p> <p>The Java-based DriveWire server uses the Apache Commons VFS libraries to access disk images. This means you have a wide variety of options available when loading and saving disk images. You can load disk images via HTTP, FTP, SFTP, CIFS, WebDAV, and from local files. You can also access files within ZIP, gzip, tar and other archives. These functions can be combined to (for instance) access a .dsk inside a ZIP file on a web server. </p> <p>Paths are specified in URI form and generally follow the rules explained in the VFS documentation. One important exception is that due to use of \"!\" as the pipe character in OS-9, you must instead use the asterisk in it's place. </p> <p>Generalization (Review Needed)</p> <p>Generalized DriveWire loading behavior.</p> <p>Many possible locations for disk images are not writable. The DriveWire server loads the disk image into a local buffer where you can make any changes you like, however these changes are not written back to the source file in these situations. You can still write the disk image to an alternate, writable location (local file, ftp, etc) using the \"dw disk write\" command. </p> <p>For example, this command loads the extras.dsk from inside the file dw_beta_1.3.tar.gz which is on the website aaronwolfe.com into drive 3: </p> <pre><code>dw disk insert 3 tgz:http://aaronwolfe.com/coco/dw_beta_1.3.tar.gz*/dwbeta/disks/extras.dsk\n</code></pre> <p>And this command would save the disk image in drive 3 to the incoming directory of the MaltedMedia FTP server: </p> <pre><code>dw disk write 3 ftp://maltedmedia.com/incoming/test_please_delete.dsk\n</code></pre> <p>Disk images located on filesystems which support random access writes (generally local or LAN file systems) will be automatically synced to disk using lazy writes (the interval at which this sync occurs is adjustable in the config file). Basically, disks located in places that DriveWire 3 can use will work as DriveWire 3 does: writes will be done automatically for you. Disks from remote locations will generally require you to use the \"disk write\" command if you want to save changes. </p> <p>You can use the \"dw disk show #\" command to show what type of filesystem a current disk image is located on if you are not sure. You can also check for dirty sectors (changed sectors which have not been written to disk) using the \"dw server show\" or \"dw disk show #\" commands. </p> <p>The \"dw server list\" and \"dw server dir\" commands support the same paths as the dw disk commands. You can use them together as a poor man's FTP/SFTP client. Redirecting the output of dw server list to a local file essentially downloads that file to local disk. </p> <p>For example, to list the files inside the gzipped tar file on a web server, you could do something like this: </p> <pre><code>dw server dir tgz:http://aaronwolfe.com/coco/dw_beta_1.3.tar.gz*/dwbeta/disks\n</code></pre> <p>And to download a file from an FTP site onto your local disk, you could do this: </p> <pre><code>dw server list ftp://www.rtsi.com/OS9/OS9_6X09/GAMES/cave.lzh &amp;gt; /dd/games/cave.lzh\n</code></pre> <p>To save time, remember that all commands may be abbreviated to their shortest unique form. \"dw d i 3\" is equivalent to \"dw disk insert 3\". </p>"},{"location":"Using_DriveWire/#ports","title":"Ports","text":"<p>(Image: DWPorts.png) </p> <p>Generalization (Review Needed)</p> <p>Generalized port terminology.</p> <p>Ports, ports and more ports... Modern DriveWire lets you specify lots of ports. I've received several questions about what they all do, so here's an attempt to clarify. </p> <p>First of all, we're talking about TCP/IP ports here. Although there are some defaults, any free valid TCP port number may be used for any DW setting. TCP/IP port numbers range from 1 to 65535. It is generally best to avoid port numbers below 1024 unless you have a specific need, as these are conventionally reserved for system processes. </p>"},{"location":"Using_DriveWire/#server-ports","title":"Server ports","text":"<p>These are TCP ports used by the server itself, so only one is needed (unless you run multiple copies of the server, but that is rarely needed since each server can support many CoCos). </p>"},{"location":"Using_DriveWire/#uiport","title":"UIPort","text":"<p>This server port is used for communication between the server and any user interfaces. The single port can support a virtually unlimited number of UI clients. It defaults to 6800, and is used whenever the UIEnabled setting is true. The server will start listening on this port at startup. </p> <p>Related settings in config.xml: </p> <pre><code>&amp;lt;UIEnabled&amp;gt;true&amp;lt;/UIEnabled&amp;gt;\n&amp;lt;UIPort&amp;gt;6800&amp;lt;/UIPort&amp;gt;\n</code></pre>"},{"location":"Using_DriveWire/#instance-ports","title":"Instance ports","text":"<p>These ports must be unique per instance. They become active when the instance is started, usually when the server is started but it is possible to disable instances individually or to tell the server not to start them automatically. </p>"},{"location":"Using_DriveWire/#tcpdeviceport","title":"TCPDevicePort","text":"<p>This port is used only when the instance's device type is set to 'tcp'. In this mode, the instance opens the TCPDevicePort and listens for an incoming drivewire protocol connection, similar to the serial mode where the instance opens a serial port and listens for drivewire protocol commands. This is useful for patched MESS where the bitbanger patch causes MESS to make a connection out to the drivewire server. A single incoming connection is supported per instance. </p> <p>Related settings in config.xml: </p> <pre><code>&amp;lt;DeviceType&amp;gt;tcp&amp;lt;/DeviceType&amp;gt;\n&amp;lt;TCPDevicePort&amp;gt;6799&amp;lt;/TCPDevicePort&amp;gt;\n</code></pre>"},{"location":"Using_DriveWire/#tcpclientport","title":"TCPClientPort","text":"<p>This port is used only when the instance's device type is set to 'tcpclient'. In this mode, the instance initiates an outgoing connection to the specified host and port (the port is not used on the DW server itself). This is useful for MESS patches that expect an incoming connection, or for using IP-serial adapters connected to a CoCo. A single outgoing connection is supported per instance. </p> <p>Related settings in config.xml: </p> <pre><code>&amp;lt;DeviceType&amp;gt;tcpclient&amp;lt;/DeviceType&amp;gt;\n&amp;lt;TCPClientPort&amp;gt;10001&amp;lt;/TCPClientPort&amp;gt;\n&amp;lt;TCPClientHost&amp;gt;some.host.com&amp;lt;/TCPClientHost&amp;gt;\n</code></pre>"},{"location":"Using_DriveWire/#termport","title":"TermPort","text":"<p>Generalization (Review Needed)</p> <p>Generalized virtual channel terminology.</p> <p>This instance-specific port is used in conjunction with the special 'headless' NitrOS-9 disks. When booted with these disks, the CoCo sends all I/O that normally would go to the CoCo's console out over a DriveWire virtual channel. To interact with the console, you telnet to the TermPort on the server. When specified, the instance will listen on this TCP port at all times regardless of a CoCo connection. A single incoming TCP connection is supported. </p> <p>Related settings in config.xml: </p> <pre><code>&amp;lt;TermPort&amp;gt;6801&amp;lt;/TermPort&amp;gt;\n</code></pre>"},{"location":"Using_DriveWire/#inetd","title":"inetd","text":"<p>If you are interested in using your CoCo as an internet server, for instance to telnet into your CoCo to a shell or BBS, or to run a web server on your CoCo, then you will probably want to use the inetd utility included with DriveWire. </p> <p>inetd is a special daemon that works much like inetd on a *nix system. It is a 'super server' in that it listens to many ports and can start the appropriate service based on which port a client connects to. For instance, you may want to provide a BBS on port 6809, an OS-9 shell on port 6800, and a quick listing of the proc command on port 6801. Any OS-9 program which uses standard input and output can be used as an internet server with inetd. </p>"},{"location":"Using_DriveWire/#inetdconf","title":"inetd.conf","text":"<p>You configure inetd's behavior using the file SYS/inetd.conf. Each line in this file corresponds to one service that you want to provide with your CoCo. There are several fields of information seperated by a comma. Some fields are optional but you must always have the correct number of commas on each line. </p> <p>The fields in inetd are: server_options,program,parameters </p> <p>Server options must begin with a port number. This may be followed by one or more optional flags which tell the DriveWire server more about how you'd like it to present this service to internet clients. Program and parameters are standard OS-9 paths and arguments. </p> <p>For example, to provide the output of \"dir /DD/CMDS\" on port 1234, inetd.conf would contain a line like: </p> <pre><code>1234,dir,/DD/CMDS\n</code></pre> <p>To provide an OS-9 shell to telnet users on port 6809, you might add this line: </p> <pre><code>6809 telnet auth protect banner,shell,\n</code></pre> <p>There are a couple things worth mentioning in this second example. First, even though we do not need any additional parameters to shell, we still must put the second comma after the program field. Second, in this example we've used a number of optional flags after the port number. These flags help to make the shell work better for telnet users and also help to keep out unwanted users. You may specify any or all of these flags on any line in inetd.conf. </p>"},{"location":"Using_DriveWire/#optional-flags-for-inetdconf","title":"optional flags for inetd.conf","text":"<p>telnet - Process telnet control characters prior to passing data to the CoCo. Useful to make interactive programs (shells, BBS, etc) work more like they should. If your OS-9 program understands telnet itself, or if you want a raw data path, do not specify this option. It is a helper mode to allow existing software to work better. </p> <p>banner - Present a banner file (specified in config.xml) to the client prior to connecting with the OS-9 system. </p> <p>protect - Use the IP address and geolocation banning system to prevent unwanted clients from connecting. This prevents the unwanted sources from ever talking with the CoCo, they are blocked in the DriveWire server prior to connection. </p>"},{"location":"Using_DriveWire/#printing","title":"Printing","text":"<p>In config.xml you'll find one or more printer sections like this (you can have as many as you'd like): </p> <pre><code>&amp;lt;Printer category=\"printing\"&amp;gt;\n   &amp;lt;Driver list=\"TEXT,FX80\" type=\"list\"&amp;gt;FX80&amp;lt;/Driver&amp;gt;\n   &amp;lt;OutputDir type=\"directory\"/&amp;gt;\n   &amp;lt;OutputFile type=\"file\"/&amp;gt;\n   &amp;lt;FlushCommand type=\"string\"/&amp;gt;\n   &amp;lt;CharacterFile type=\"file\"&amp;gt;default.chars&amp;lt;/CharacterFile&amp;gt;\n   &amp;lt;Columns max=\"132\" min=\"1\" type=\"int\"&amp;gt;80&amp;lt;/Columns&amp;gt;\n   &amp;lt;Lines max=\"132\" min=\"1\" type=\"int\"&amp;gt;66&amp;lt;/Lines&amp;gt;\n   &amp;lt;DPI max=\"1200\" min=\"50\" type=\"int\"&amp;gt;300&amp;lt;/DPI&amp;gt;\n   &amp;lt;ImageFormat list=\"JPG,GIF,PNG,BMP\" type=\"list\"&amp;gt;PNG&amp;lt;/ImageFormat&amp;gt;\n&amp;lt;/Printer&amp;gt;\n</code></pre> <p>Driver can be TEXT or FX80. If TEXT, Drivewire just writes whatever the CoCo sends to a file. If FX80, DW sends it to an emulated epson fx80, which then outputs image files. </p> <p>OutputDir and OutputFile specify where the output is created. If OutputFile is set, all output is written (appended) to the same specified file. Probably not what you want unless it sounds like exactly what you want. Most folks will not want to set it, and instead will set OutputDir which tells DW to create new files for each print job (or page, in FX80 mode) in the specified directory. If both are set, OutputFile wins. </p> <p>FlushCommand is any command you'd like executed after DW writes a new file or appends to the OutputFile. If the string '$file' is in this command, it will be replaced with the full path of the file DW just created. </p> <p>The remaining settings only apply to FX80 mode: </p> <p>CharacterFile is the font definition for the FX80. The default setting specifies an included file that matches the default font the FX80 used. Its a very simple human readable format. </p> <p>Columns and Lines define the dimensions of an FX80 text page. You could for instance change Columns to 132 to emulate one of those really wide variants in the epson fx family, or change Lines to simulate different paper length. The defaults match what a regular FX80 used on 8.5x11 paper. </p> <p>DPI and ImageFormat control the image files that the FX80 emulator produces. </p>"},{"location":"Using_DriveWire/#note-for-users-of-ftdi-usb-serial-adapters","title":"Note for users of FTDI USB-Serial adapters","text":"<p>Generalization (Review Needed)</p> <p>Generalized performance notes.</p> <p>While working on the server code, I found that my FTDI adapter performed about 20% slower than my Prolific adapter and a 16550 \"real\" serial port. There is a simple change that can be made in the FTDI driver's settings to bring its performance in line with the other hardware. </p> <p>Simply change the \"receive buffer latency timer\" to 4ms (from the default 16ms). In Windows, this is done in the properties of the adapter, accessible from device manager. </p>"},{"location":"Writing_Network_Capable_Software/","title":"Writing Network Capable Software","text":""},{"location":"Writing_Network_Capable_Software/#introduction","title":"Introduction","text":"<p>DriveWire's approach to networking is to let the server do the \"heavy lifting\" of the TCP/IP stack and shift the burden away from the CoCo. This lets software developers enjoy the convenience of sending simple commands to initiate an outgoing connection or listening for an incoming one. If you compare getting a network application up and running under NitrOS-9 and DriveWire vis a vis other operating systems, you will quickly see that it is much easier on your CoCo using this method.</p> <p>The steps for obtaining and using a network resource under NitrOS-9 consists of these basic steps:</p> <ol> <li>Obtain a path to a network device</li> <li>Set up the port by sending appropriate messages to the server on the path</li> <li>Perform subsequent reading and writing to the path to pass data</li> </ol>"},{"location":"Writing_Network_Capable_Software/#using-the-network-library","title":"Using the Network Library","text":"<p>For convenience, a network library has been written to provide application writers with some common routines for network access. The library is written in assembly language and requires developers to use the RMA assembler and RLINK linker when writing their applications.</p>"},{"location":"Writing_Network_Capable_Software/#getting-a-path","title":"Getting a Path","text":"<p>To obtain a path to the network, your program needs to call the <code>TCPOpen</code> routine. The path number of the network path is returned in register A.</p>"},{"location":"Writing_Network_Capable_Software/#setting-up-the-path","title":"Setting up the Path","text":"<p>Depending on whether your application is a client or server, you will want to call one of the following routines:</p> <ul> <li><code>TCPConnectToHost</code></li> <li><code>TCPListen</code></li> </ul>"},{"location":"Writing_Network_Capable_Software/#acting-like-a-host-listening","title":"Acting like a Host (Listening)","text":"<p>If you are writing a network application that will act as a host (or server), then you need to inform the DriveWire server of your intent by calling the <code>TCPListen</code> routine.</p>"},{"location":"Writing_Network_Capable_Software/#acting-a-client","title":"Acting a Client","text":"<p>As a client, your application is interested in connecting to a host on the other end. To do this, call <code>TCPConnectToHost</code>.</p>"},{"location":"Writing_Network_Capable_Software/#example-applications","title":"Example Applications","text":"<p>The best way to learn is to look at existing code. For an example of writing a host application, see the inetd.a source code. For a client application, see the telnet.a source file.</p>"}]}